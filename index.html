<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arabic Word Similarity — Vue 3 Tester + Ayah Builder</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <style>
    :root { --bg:#0b1020; --card:#121933; --muted:#9aa4c7; --text:#e7ecff; --accent:#7aa2f7; --bad:#ff6b6b; --good:#3ddc97; }
    html,body { height:100%; }
    body { margin:0; font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif; background:var(--bg); color:var(--text); }
    .container { max-width: 1080px; margin: 32px auto; padding: 0 16px; }
    .card { background: var(--card); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); padding: 20px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .tabs { display:flex; gap:10px; }
    .tab-btn { background:#131c3b; border:1px solid #2b3770; padding:8px 12px; border-radius:12px; cursor:pointer; }
    .tab-btn.active { background:#1a2552; border-color:#3a4aa0; }
    input[type="number"], select { background:#0e1530; border:1px solid #263055; color:var(--text); padding:10px 12px; border-radius:12px; font-size:16px; }
    input[type="number"] { width:120px; }
    button { background: #1a2552; border:1px solid #2e3a72; color: var(--text); padding:10px 14px; border-radius:12px; cursor: pointer; }
    button:hover { background:#233067; }
    .muted { color: var(--muted); }
    .title { font-size: 22px; margin: 0 0 12px 0; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #2a3562; padding: 10px; text-align: left; }
    th { color: var(--muted); font-weight:600; }
    .badge { display:inline-block; background:#233067; border:1px solid #2f3b73; padding:4px 10px; border-radius:999px; font-size:12px; color:var(--muted); }
    .word { font-size: 28px; font-weight: 700; letter-spacing: .2px; }
    .footer { margin-top: 20px; font-size: 13px; color: var(--muted); }
    .flex-between { display:flex; justify-content: space-between; align-items:center; gap: 10px; }

    /* Game UI */
    .slots { display:flex; flex-wrap:wrap; gap:10px; }
    .slot {
      min-width: 80px; min-height: 44px; padding: 6px 10px;
      border: 2px dashed #2a3562; border-radius: 12px; background:#0f1734;
      display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none;
    }
    .slot.active { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(122,162,247,.15) inset; }
    .slot.checked.good { border-color: rgba(61,220,151,.9); background: rgba(61,220,151,.08); }
    .slot.checked.bad  { border-color: rgba(255,107,107,.9); background: rgba(255,107,107,.06); }
    .slot .placeholder { color:#445089; font-size:18px; }
    .slot .token { font-size: 22px; }

    .token-btn {
      display:inline-block; padding:10px 12px; border-radius:12px;
      border:1px solid #2f3b73; background:#1a2552; margin:6px; cursor:pointer;
      user-select:none; font-size:22px;
    }
    .token-btn:hover { background:#233067; }

    .ayah-preview { font-size:22px; line-height:1.8; white-space:pre-wrap; }

    details summary { cursor:pointer; color: var(--muted); }

    /* RTL -------------------------------------------------- */
    .rtl { direction: rtl; }                   /* makes rows flow right-to-left */
    .ayah-preview.rtl { text-align: right; }   /* nicer for reading Arabic */
  </style>
</head>
<body>
  <div id="app" class="container">
    <div class="card" style="margin-bottom:16px;">
      <div class="flex-between">
        <h1 class="title">Arabic Word Tools — Vue 3</h1>
        <div class="tabs">
          <button class="tab-btn" :class="{active: tab==='tester'}" @click="tab='tester'">Tester</button>
          <button class="tab-btn" :class="{active: tab==='game'}" @click="tab='game'">Game</button>
        </div>
      </div>

      <div class="row" style="gap:8px; margin-top:10px;">
        <span class="badge">Mode:</span>
        <button :class="{ active: !useNoDiacritics }" @click="setMode(false)">With Diacritics (Hard)</button>
        <button :class="{ active: useNoDiacritics }" @click="setMode(true)">No Diacritics (Easy)</button>
        <span class="badge" v-if="entries.length && tab==='tester'">{{ entries.length.toLocaleString() }} words</span>
      </div>
    </div>

    <!-- TESTER TAB (unchanged core) -->
    <template v-if="tab==='tester'">
      <div class="card" v-if="current">
        <div class="row" style="margin-bottom:12px;">
          <input type="number" :max="Math.max(entries.length-1, 0)" min="0" v-model.number="index" @change="clampIndex" />
          <button @click="index = Math.max(index-1, 0)">Prev</button>
          <button @click="index = Math.min(index+1, Math.max(entries.length-1, 0))">Next</button>
          <button @click="randomIndex">Random</button>
          <span class="muted">Current index: {{ index }}</span>
        </div>
        <div class="row"><span class="muted">Word</span><div class="word">{{ current.word }}</div></div>
        <div class="muted" style="margin-top:6px;">Top {{ current.sims.length }} similar words</div>
        <table style="margin-top:10px;">
          <thead><tr><th style="width:60%">Word</th><th>Score</th></tr></thead>
          <tbody>
            <tr v-for="(pair, i) in current.sims" :key="i">
              <td>{{ pair[0] }}</td>
              <td>{{ formatScore(pair[1]) }}</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="card" v-else><div class="muted">Loading {{ activeFilename }}...</div></div>
      <div class="footer">JSON format: { "word": [["other", 0.92], ...], ... } — toggle loads <code>similarities_diacritics.json</code> or <code>similarities_no_diacritics.json</code>.</div>
    </template>

    <!-- GAME TAB: AYAH BUILDER -->
    <template v-else>
      <div class="card" style="margin-bottom:16px;">
        <div class="row">
          <label class="badge">Surah</label>
          <input type="number" min="1" max="114" v-model.number="surah" @change="loadSurah" />
          <label class="badge">Ayah</label>
          <select v-model.number="ayahIndex" @change="prepareAyah" :disabled="!ayahs.length">
            <option v-for="(a, i) in ayahs" :key="i" :value="i">{{ i+1 }}</option>
          </select>
          <button @click="randomAyah" :disabled="!ayahs.length">Random Ayah</button>
          <span class="badge" v-if="tokens.length">Words: {{ tokens.length }}</span>
        </div>

        <!-- Hidden preview behind toggle; joins with spaces -->
        <details style="margin-top:10px;">
          <summary>Show Ayah (answer)</summary>
          <div class="ayah-preview rtl" style="margin-top:8px;" v-if="tokens.length">
            {{ tokens.join(' ') }}
          </div>
        </details>
      </div>

      <div class="card" v-if="tokens.length">
        <div class="row" style="justify-content:space-between;">
          <div class="muted">Build the ayah by filling each slot. Select a slot, then choose a word from the bank.</div>
          <div class="row">
            <button @click="clearAll">Clear All</button>
            <button @click="reshuffle">Shuffle Options</button>
            <button @click="checkGuess" :disabled="!isFilled">Check</button>
          </div>
        </div>

        <!-- Slots: now flow right-to-left so the first word sits on the right -->
        <div class="slots rtl" style="margin-top:10px;">
          <div v-for="(g,i) in guess" :key="i"
               class="slot"
               :class="slotClass(i)"
               @click="setActive(i)"
               :title="'Word '+(i+1)">
            <span v-if="g" class="token">{{ g }}</span>
            <span v-else class="placeholder">—</span>
          </div>
        </div>

        <div class="row" style="margin-top:14px; justify-content:space-between; align-items:center;">
          <div class="row">
            <span class="badge">Active Slot:</span>
            <span class="badge">{{ activeSlot+1 }} / {{ tokens.length }}</span>
          </div>
          <div class="row">
            <button @click="prevSlot" :disabled="activeSlot<=0">Prev Slot</button>
            <button @click="nextSlot" :disabled="activeSlot>=tokens.length-1">Next Slot</button>
          </div>
        </div>

        <div class="muted" style="margin-top:10px;">Word Bank (for current slot)</div>
        <div class="rtl" style="margin-top:4px;">
          <span v-for="(opt,i) in options" :key="i"
                class="token-btn"
                @click="choose(opt)">
            {{ opt }}
          </span>
          <span v-if="!options.length" class="muted">No options — check your JSONs / mode.</span>
        </div>

        <div class="row" style="margin-top:12px;" v-if="checked">
          <span class="badge" v-if="allCorrect">✅ Perfect!</span>
          <span class="badge" v-else>❌ Incorrect slots: {{ wrongPositions.join(', ') }}</span>
        </div>
      </div>

      <div class="card" v-else>
        <div class="muted">Load a surah to begin.</div>
      </div>
    </template>
  </div>

  <script>
  const { createApp } = Vue;

  // --- Helpers (match preprocessor) ---
  const ARABIC_DIACRITICS_RE = /[\u0617-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E8\u06EA-\u06ED]/g;
  const INVISIBLES_RE = /[\ufeff\u200b\u200c\u200d\u2060]/g;
  const stripInvisibles = s => (s || '').replace(INVISIBLES_RE, '');
  const stripDiacritics = s => (s || '').replace(ARABIC_DIACRITICS_RE, '');
  const norm = s => (s || '').normalize('NFC');
  function tokenizeSpace(line, { noDia=false } = {}) {
    line = stripInvisibles(line);
    const raw = line.split(/\s+/).filter(Boolean);
    return raw
      .map(w => {
        w = norm(stripInvisibles(w.trim()));
        return noDia ? stripDiacritics(w) : w;
      })
      .filter(w => w.length > 1);
  }

  createApp({
    data() {
      return {
        tab: 'game',

        // tester data
        entries: [],
        map: {},           // { word: [[other, score], ...], ... }
        index: 0,

        // shared
        useNoDiacritics: false,

        // game
        surah: 1,
        ayahs: [],
        ayahIndex: 0,
        tokens: [],        // target tokens for the ayah, normalized to mode
        guess: [],         // user selections (same length as tokens)
        activeSlot: 0,     // which slot is selected
        options: [],       // word bank for the activeSlot's target word

        // feedback
        checked: false,
        perCorrect: [],
      }
    },
    computed: {
      activeFilename() {
        return this.useNoDiacritics ? 'similarities_no_diacritics.json' : 'similarities_diacritics.json';
      },
      current() {
        if (!this.entries.length) return null;
        const i = Math.max(0, Math.min(this.index, this.entries.length - 1));
        return this.entries[i];
      },
      isFilled() {
        return this.tokens.length && this.guess.every(Boolean);
      },
      allCorrect() {
        return this.checked && this.perCorrect.length && this.perCorrect.every(Boolean);
      },
      wrongPositions() {
        if (!this.checked) return [];
        const res = [];
        for (let i = 0; i < this.perCorrect.length; i++) {
          if (!this.perCorrect[i]) res.push(i + 1);
        }
        return res;
      }
    },
    methods: {
      // -------- Mode + files --------
      async loadActive() {
        try {
          const res = await fetch(this.activeFilename, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const obj = await res.json();
          const keys = Object.keys(obj);
          this.entries = keys.map(k => ({ word: k, sims: obj[k] })).filter(e => Array.isArray(e.sims));
          this.map = obj;
          this.index = 0;
          // refresh options if in a round
          if (this.tokens.length) this.buildOptions();
        } catch (err) {
          this.entries = [];
          this.map = {};
          alert('Could not read ' + this.activeFilename + ': ' + err.message + '\n(Ensure JSONs exist and use a local server)');
        }
      },
      setMode(noDia) {
        if (this.useNoDiacritics === noDia) return;
        this.useNoDiacritics = noDia;
        this.loadActive();
        if (this.ayahs.length) this.prepareAyah();
      },
      clampIndex() {
        if (!this.entries.length) return;
        this.index = Math.max(0, Math.min(this.index, this.entries.length - 1));
      },
      randomIndex() {
        if (!this.entries.length) return;
        this.index = Math.floor(Math.random() * this.entries.length);
      },

      // -------- Surah / Ayah --------
      async loadSurah() {
        try {
          const url = `https://api.alquran.cloud/v1/surah/${this.surah}/quran-uthmani`;
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const data = await res.json();
          if (data.status !== 'OK') throw new Error(data.message || 'API error');
          this.ayahs = (data.data?.ayahs || []).map(a => a.text || '');
          this.ayahIndex = 0;
          this.prepareAyah();
        } catch (e) {
          this.ayahs = [];
          this.tokens = [];
          this.guess = [];
          this.activeSlot = 0;
          this.options = [];
          this.checked = false;
          this.perCorrect = [];
          alert('Failed to load surah: ' + e.message);
        }
      },
      prepareAyah() {
        const noDia = this.useNoDiacritics;
        const line = this.ayahs[this.ayahIndex] || '';
        this.tokens = tokenizeSpace(line, { noDia });
        this.guess = Array(this.tokens.length).fill('');
        this.activeSlot = 0;
        this.checked = false;
        this.perCorrect = [];
        this.buildOptions();
      },
      async randomAyah() {
        // pick random surah (1–114)
        this.surah = Math.floor(Math.random() * 114) + 1;

        // load surah (API call)
        await this.loadSurah();

        // pick random ayah within it
        if (this.ayahs.length) {
          this.ayahIndex = Math.floor(Math.random() * this.ayahs.length);
          this.prepareAyah();
        }
      },

      // -------- Bank for current slot --------
      lookupSimilar(word) {
        if (this.map[word]) return this.map[word];
        const keyNoDia = stripDiacritics(word);
        if (!this.useNoDiacritics && this.map[keyNoDia]) return this.map[keyNoDia];
        return [];
      },
      buildOptions() {
        const target = this.tokens[this.activeSlot] || '';
        const set = new Set();
        if (target) set.add(target);
        const sims = target ? this.lookupSimilar(target) : [];
        for (const [other, _s] of sims) {
          set.add(this.useNoDiacritics ? stripDiacritics(other) : other);
        }
        // basic dedupe + remove 1-char
        const arr = Array.from(set).filter(w => w && w.length > 1);
        // shuffle
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        this.options = arr;
      },
      reshuffle() { this.buildOptions(); },

      // -------- Slots & choosing --------
      setActive(i) {
        this.activeSlot = i;
        this.checked = false; // reset feedback until next check
        this.perCorrect = [];
        this.buildOptions();
      },
      choose(opt) {
        // set the chosen word in the current slot
        this.guess[this.activeSlot] = opt;

        // move to the next empty slot (right-to-left UI, but indices still increase)
        const nextEmpty = this.guess.findIndex((g, i) => !g && i > this.activeSlot);
        if (nextEmpty !== -1) {
          this.activeSlot = nextEmpty;
        } else if (this.activeSlot < this.guess.length - 1) {
          this.activeSlot++;
        }

        // show the correct word bank for the newly active slot
        this.buildOptions();

        // any prior check results are now stale
        this.checked = false;
        this.perCorrect = [];
      },     
      clearAll() {
        this.guess = Array(this.tokens.length).fill('');
        this.checked = false;
        this.perCorrect = [];
        this.activeSlot = 0;
        this.buildOptions();
      },
      prevSlot() { if (this.activeSlot > 0) { this.activeSlot--; this.buildOptions(); } },
      nextSlot() { if (this.activeSlot < this.tokens.length - 1) { this.activeSlot++; this.buildOptions(); } },

      // -------- Checking --------
      checkGuess() {
        if (!this.isFilled) {
          alert('Fill all slots before checking.');
          return;
        }
        const eq = (a, b) => this.useNoDiacritics ? stripDiacritics(a) === stripDiacritics(b) : a === b;
        this.perCorrect = this.guess.map((g, i) => eq(g, this.tokens[i]));
        this.checked = true;
      },
      slotClass(i) {
        return {
          active: i === this.activeSlot,
          checked: this.checked,
          good: this.checked && this.perCorrect[i],
          bad:  this.checked && !this.perCorrect[i],
        };
      },
      formatScore(s) { return typeof s === 'number' ? s.toFixed(3) : s; }
    },
    async mounted() {
      await this.loadActive();
      await this.loadSurah();  // default surah 1
    }
  }).mount('#app');
  </script>
</body>
</html>
