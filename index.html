<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Arabic Word Similarity — Vue 3 Tester + Ayah Builder</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

  <!-- Hafs Uthmani webfont -->
  <link href="https://fonts.cdnfonts.com/css/kfgqpc-hafs-uthmanic-script" rel="stylesheet">

  <style>
    :root {
      --bg:#ffffff;
      --card:#fafafa;
      --muted:#666666;
      --text:#222222;
      --accent:#ff7a00; /* orange accent */
      --bad:#e63946;
      --good:#2a9d8f;
      --overlay: rgba(0,0,0,.35);
    }
    html,body { height:100%; }
    body {
      margin:0;
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", sans-serif;
      background:var(--bg);
      color:var(--text);
      padding-bottom: 160px; /* space so content isn't behind the floating word bank */
    }

    /* Arabic font utility */
    .arabic, .rtl, .ayah-preview, .token, .token-btn {
      font-family: 'KFGQPC HAFS Uthmanic Script', 'Scheherazade New', 'Amiri', 'Noto Naskh Arabic', serif;
      font-variant-ligatures: contextual;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container { max-width: 1080px; margin: 24px auto; padding: 0 16px; }
    .card {
      background: var(--card);
      border-radius: 16px;
      box-shadow: 0 4px 16px rgba(0,0,0,.1);
      padding: 20px;
    }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .title { font-size: 22px; margin: 0; }
    .muted { color: var(--muted); }

    /* Buttons / inputs */
    .btn {
      background: var(--accent);
      border:1px solid var(--accent);
      color: #fff;
      padding:10px 14px;
      border-radius:12px;
      cursor: pointer;
      transition: background .15s ease, border-color .15s ease, box-shadow .15s ease;
    }
    .btn:hover { background:#e66c00; border-color:#e66c00; }
    .btn.secondary {
      background:#fff; color:var(--text);
      border-color:#ddd;
    }
    .btn.secondary:hover { background:#fff3e6; border-color: var(--accent); color:var(--accent); }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .input, .select {
      background:#fff;
      border:1px solid #ccc;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:16px;
    }
    .select { min-width: 120px; }
    .badge {
      display:inline-block;
      background:#fff3e6;
      border:1px solid #ffd5b3;
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      color: var(--accent);
    }

    /* Fixed gear button (true top-left of viewport, under overlay) */
    .fixed-gear {
      position: fixed;
      top: max(12px, env(safe-area-inset-top));
      left: max(12px, env(safe-area-inset-left));
      background:#fff; border:1px solid #ddd; border-radius:12px; padding:8px; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      box-shadow: 0 2px 8px rgba(0,0,0,.06);
      z-index: 1000; /* BELOW overlay/sidebar */
    }
    .fixed-gear:hover { border-color: var(--accent); background:#fff3e6; }
    .gear-icon { width:22px; height:22px; display:block; }

    /* Header */
    .header {
      display:flex; align-items:center; justify-content:center;
      margin-bottom: 12px;
    }

    /* Sidebar (left drawer) */
    .sidebar-overlay {
      position: fixed; inset: 0; background: var(--overlay);
      display: none; z-index: 1200;
    }
    .sidebar-overlay.open { display:block; }
    .sidebar {
      position: fixed; top:0; left:0; height:100%; width: 320px; max-width: 90vw;
      background:#fff; box-shadow: 4px 0 24px rgba(0,0,0,.15);
      transform: translateX(-100%); transition: transform .25s ease;
      z-index: 1201; display:flex; flex-direction:column;
    }
    .sidebar.open { transform: translateX(0); }
    .sidebar-header {
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 16px; border-bottom:1px solid #eee;
    }
    .sidebar-title { font-weight:600; }
    .sidebar-content { padding: 16px; overflow:auto; }
    .field { display:flex; flex-direction:column; gap:6px; margin-bottom:14px; }
    .field label { font-size: 13px; color: var(--muted); }
    .segmented {
      display:inline-flex; background:#fafafa; border:1px solid #ddd; border-radius:12px; overflow:hidden;
    }
    .segmented button {
      border:0; padding:8px 12px; cursor:pointer; background:transparent;
    }
    .segmented button.active { background: var(--accent); color:#fff; }

    /* Tester table */
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #ddd; padding: 10px; text-align: left; }
    th { color: var(--muted); font-weight:600; }

    /* Centered mode icon toggle (connected circles) */
    .mode-icons {
      position: relative;
      max-width: 360px;
      margin: 0 auto 12px;
      padding: 18px 48px; /* side padding */
      display:flex;
      align-items:center;
      justify-content:space-between;
      user-select:none;
    }
    /* EXACT OFFSETS FROM YOUR REQUEST */
    .mode-icons::before {
      content:'';
      position:absolute;
      top:50%;
      left:115px;
      right:112px;
      height:2px;
      background:#ffd5b3;
      transform: translateY(-50%);
      pointer-events:none;
    }
    .circle-toggle {
      width:64px; height:64px; border-radius:50%;
      background:#fff; border:2px solid #ffd5b3; color:var(--text);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; transition: transform .05s ease, background .15s ease, border-color .15s ease, color .15s ease, box-shadow .15s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,.04);
    }
    .circle-toggle:active { transform: translateY(1px); }
    .circle-toggle .glyph { font-size:30px; line-height:1; }
    .circle-toggle.active {
      background: var(--accent);
      border-color: var(--accent);
      color:#fff;
      box-shadow: 0 0 0 6px rgba(255,122,0,.12);
    }
    .circle-toggle:hover { border-color: var(--accent); }

    /* Game UI */
    .slots { display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
    .slot {
      min-width: 90px; min-height: 56px; padding: 8px 12px;
      border: 2px dashed #ddd; border-radius: 12px; background:#fff;
      display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none;
    }
    .slot.active { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(255,122,0,.15) inset; }
    .slot.checked.good { border-color: var(--good); background: rgba(42,157,143,.1); }
    .slot.checked.bad  { border-color: var(--bad); background: rgba(230,57,70,.08); }
    .slot .placeholder { color:#aaa; font-size:20px; }
    .slot .token { font-size: 26px; }

    /* Big wide actions under slots */
    .actions { display:flex; gap:12px; margin-top:16px; }
    .action-btn {
      flex:1; border-radius:14px; padding:16px; font-size:18px;
      display:flex; align-items:center; justify-content:center; gap:10px;
      cursor:pointer; border:1px solid transparent;
      transition: background .15s ease, border-color .15s ease, transform .05s ease;
    }
    .action-btn:active { transform: translateY(1px); }
    .action-btn.secondary { background:#fff; border-color:#ddd; color:var(--text); }
    .action-btn.secondary:hover { background:#fff3e6; border-color: var(--accent); color:var(--accent); }
    .action-btn.primary { background: var(--accent); color:#fff; border-color: var(--accent); }
    .action-btn.primary:disabled { opacity:.5; cursor:not-allowed; }
    .action-btn svg { width:24px; height:24px; display:block; }

    /* Success / fail pulse animations for the Check button */
    @keyframes pulseGreen {
      0% { box-shadow: 0 0 0 0 rgba(42,157,143,.7); }
      70% { box-shadow: 0 0 0 14px rgba(42,157,143,0); }
      100% { box-shadow: 0 0 0 0 rgba(42,157,143,0); }
    }
    @keyframes pulseRed {
      0% { box-shadow: 0 0 0 0 rgba(230,57,70,.7); }
      70% { box-shadow: 0 0 0 14px rgba(230,57,70,0); }
      100% { box-shadow: 0 0 0 0 rgba(230,57,70,0); }
    }
    .sim-success {
      animation: pulseGreen 900ms ease-out;
      background: var(--good) !important;
      border-color: var(--good) !important;
      color:#fff !important;
    }
    .sim-fail {
      animation: pulseRed 900ms ease-out;
      background: var(--bad) !important;
      border-color: var(--bad) !important;
      color:#fff !important;
    }

    .token-btn {
      display:inline-block; padding:12px 14px; border-radius:12px;
      border:1px solid #ddd; background:#fff; margin:6px; cursor:pointer;
      user-select:none; font-size:26px; color:var(--text);
    }
    .token-btn:hover { background:#fff3e6; border-color: var(--accent); color:var(--accent); }

    /* Floating word bank */
    .word-bank {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #fafafa;
      border-top: 2px solid #eee;
      padding: 12px 16px;
      text-align: center;
      box-shadow: 0 -2px 8px rgba(0,0,0,.05);
      z-index: 1100;
    }
    .word-bank .muted { display:block; margin-bottom:8px; }
    .word-bank-inner { max-width: 1080px; margin: 0 auto; padding: 0 8px; }

    .ayah-preview { font-size:28px; line-height:2; white-space:pre-wrap; }

    /* RTL */
    .rtl { direction: rtl; }
    .ayah-preview.rtl { text-align: right; }
  </style>
</head>
<body>
  <div id="app">
    <!-- Fixed gear button at true top-left (beneath overlay/sidebar) -->
    <button class="fixed-gear" @click="sidebarOpen = true" title="Settings">
      <svg class="gear-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z"/>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06A1.65 1.65 0 0 0 15 19.4a1.65 1.65 0 0 0-1 .6 1.65 1.65 0 0 0-.33 1.82V22a2 2 0 1 1-4 0v-.18A1.65 1.65 0 0 0 8 19.4a1.65 1.65 0 0 0-1 .6 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.6 15a1.65 1.65 0 0 0-.6-1 1.65 1.65 0 0 0-1.82-.33H2a2 2 0 1 1 0-4h.18A1.65 1.65 0 0 0 4.6 8a1.65 1.65 0 0 0 .6-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06A2 2 0 1 1 7.64 1.3l.06.06A1.65 1.65 0 0 0 9 4.6a1.65 1.65 0 0 0 1-.6 1.65 1.65 0 0 0 .33-1.82V2a2 2 0 1 1 4 0v.18A1.65 1.65 0 0 0 16 4.6c.36 0 .72-.13 1-.6l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9c0 .36.13.72.6 1 .31.19.66.3 1.02.33H22a2 2 0 1 1 0 4h-.18a1.65 1.65 0 0 0-1.82.33c-.47.28-.6.64-.6 1Z"/>
      </svg>
    </button>

    <!-- Sidebar overlay + drawer -->
    <div class="sidebar-overlay" :class="{ open: sidebarOpen }" @click="sidebarOpen=false"></div>
    <aside class="sidebar" :class="{ open: sidebarOpen }" @click.stop>
      <div class="sidebar-header">
        <div class="sidebar-title">Settings</div>
        <button class="btn secondary" @click="sidebarOpen=false">Close</button>
      </div>
      <div class="sidebar-content">
        <div class="field">
          <label>Mode</label>
          <div class="segmented">
            <button :class="{active: tab==='game'}" @click="tab='game'">Game</button>
            <button :class="{active: tab==='tester'}" @click="tab='tester'">Tester</button>
          </div>
        </div>

        <div class="field">
          <label>Surah (1–114)</label>
          <input class="input" type="number" min="1" max="114" v-model.number="surah" />
          <div class="row" style="margin-top:6px;">
            <button class="btn" @click="loadSurah">Load Surah</button>
            <button class="btn secondary" @click="randomAyah" :disabled="loadingSurah">Random</button>
          </div>
        </div>

        <div class="field">
          <label>Ayah</label>
          <select class="select" v-model.number="ayahIndex" :disabled="!ayahs.length" @change="prepareAyah">
            <option v-for="(a, i) in ayahs" :key="i" :value="i">{{ i+1 }}</option>
          </select>
        </div>

        <!-- NEW: Repetition setting -->
        <div class="field">
          <label>Repetition (times per mode)</label>
          <input class="input" type="number" min="1" max="20" v-model.number="repetitionTarget" @change="resetRepetitions" />
          <div class="muted">Complete this many rounds in No Diacritics, then the same in With Diacritics.</div>
        </div>

        <!-- NEW: Verse range -->
        <div class="field">
          <label>Verse Range (within current surah)</label>
          <div class="row">
            <div style="display:flex; flex-direction:column; gap:6px;">
              <small class="muted">Start</small>
              <input class="input" type="number" :min="1" :max="ayahs.length || 1" v-model.number="rangeStart" @change="normalizeRange(true)" />
            </div>
            <div style="display:flex; flex-direction:column; gap:6px;">
              <small class="muted">End</small>
              <input class="input" type="number" :min="1" :max="ayahs.length || 1" v-model.number="rangeEnd" @change="normalizeRange(false)" />
            </div>
          </div>
          <div class="muted">Defaults to 1 … {{ ayahs.length || 1 }} for this surah.</div>
        </div>

        <div class="field" v-if="tab==='tester' && entries.length">
          <label>Tester: Word Index</label>
          <input class="input" type="number" :max="Math.max(entries.length-1, 0)" min="0" v-model.number="index" @change="clampIndex" />
          <div class="row" style="margin-top:6px;">
            <button class="btn secondary" @click="index = Math.max(index-1, 0)">Prev</button>
            <button class="btn secondary" @click="index = Math.min(index+1, Math.max(entries.length-1, 0))">Next</button>
            <button class="btn" @click="randomIndex">Random</button>
          </div>
          <div class="muted" style="margin-top:6px;">Words loaded: {{ entries.length.toLocaleString() }}</div>
        </div>
      </div>
    </aside>

    <div class="container">
      <!-- Header with centered title -->
      <div class="header">
        <h1 class="title">Arabic Word Tools — Vue 3</h1>
      </div>

      <!-- MODE ICONS (left: No Diacritics, right: With Diacritics) -->
      <div class="mode-icons" role="group" aria-label="Diacritics mode">
        <!-- No Diacritics (Easy) - LEFT -->
        <button
          class="circle-toggle arabic"
          :class="{ active: useNoDiacritics }"
          @click="setMode(true)"
          aria-pressed="useNoDiacritics"
          title="No Diacritics (Easy)">
          <span class="glyph">ب</span>
        </button>

        <!-- With Diacritics (Hard) - RIGHT -->
        <button
          class="circle-toggle arabic"
          :class="{ active: !useNoDiacritics }"
          @click="setMode(false)"
          aria-pressed="!useNoDiacritics"
          title="With Diacritics (Hard)">
          <span class="glyph">بَ</span>
        </button>
      </div>

      <!-- CONTENT -->
      <template v-if="tab==='tester'">
        <div class="card" v-if="current">
          <div class="row" style="margin-bottom:8px;">
            <span class="badge">Index: {{ index }}</span>
          </div>
          <div class="row"><span class="muted">Word</span><div class="word arabic rtl">{{ current.word }}</div></div>
          <div class="muted" style="margin-top:6px;">Top {{ current.sims.length }} similar words</div>
          <table style="margin-top:10px;">
            <thead><tr><th style="width:60%">Word</th><th>Score</th></tr></thead>
            <tbody>
              <tr v-for="(pair, i) in current.sims" :key="i">
                <td class="arabic rtl">{{ pair[0] }}</td>
                <td>{{ formatScore(pair[1]) }}</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="card" v-else><div class="muted">Loading {{ activeFilename }}...</div></div>
      </template>

      <!-- GAME TAB -->
      <template v-else>
        <div class="card" style="margin-bottom:16px;">
          <div class="muted">
            Build the ayah one slot at a time. Only the next slot is revealed. Selecting a word reveals the following slot automatically.
          </div>
          <div class="row" style="margin-top:8px;">
            <span class="badge">Mode: {{ useNoDiacritics ? 'No Diacritics' : 'With Diacritics' }}</span>
            <span class="badge">Reps: {{ repetitionCount }} / {{ repetitionTarget }}</span>
            <span class="badge">Range: {{ rangeStart }} → {{ rangeEnd }}</span>
            <span class="badge">Ayah: {{ ayahIndex + 1 }}</span>
          </div>
          <details style="margin-top:10px;">
            <summary>Show Ayah (answer)</summary>
            <div class="ayah-preview rtl arabic" style="margin-top:8px;" v-if="tokens.length">
              {{ tokens.join(' ') }}
            </div>
          </details>
        </div>

        <div class="card" v-if="tokens.length">
          <!-- Slots: only revealed portion; centered, RTL -->
          <div class="slots rtl arabic" style="margin-top:10px;">
            <div v-for="(g,i) in guess.slice(0, revealedCount)" :key="i"
                 class="slot"
                 :class="slotClass(i)"
                 @click="setActive(i)"
                 :title="'Word '+(i+1)">
              <span v-if="g" class="token">{{ g }}</span>
              <span v-else class="placeholder">—</span>
            </div>
          </div>

          <!-- Big wide actions under slots -->
          <div class="actions">
            <!-- Reset (circular arrow) -->
            <button class="action-btn secondary" @click="clearAll" title="Reset">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M3 2v6h6"/>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L3 8"/>
              </svg>
              Reset
            </button>

            <!-- Check (orange, white checkmark) -->
            <button
              class="action-btn primary"
              :class="{'sim-success': checkPulse==='success', 'sim-fail': checkPulse==='fail'}"
              :disabled="!isFilled"
              @click="checkGuess"
              title="Check">
              <svg viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M20 6L9 17l-5-5"/>
              </svg>
              Check
            </button>
          </div>

          <!-- feedback -->
          <div class="row" style="margin-top:12px;" v-if="checked">
            <span class="badge" v-if="allCorrect">✅ Correct!</span>
            <span class="badge" v-else>❌ Incorrect slots: {{ wrongPositions.join(', ') }}</span>
          </div>
        </div>

        <div class="card" v-else>
          <div class="muted">Load a surah to begin (gear icon).</div>
        </div>
      </template>
    </div> <!-- /.container -->

    <!-- Floating word bank (inside #app so Vue renders it) -->
    <div class="word-bank" v-if="tab==='game' && tokens.length">
      <div class="word-bank-inner">
        <span class="muted">Word Bank</span>
        <div class="rtl arabic">
          <span v-for="(opt,i) in options" :key="i"
                class="token-btn"
                @click="choose(opt)">
            {{ opt }}
          </span>
          <span v-if="!options.length" class="muted">No options — check your JSONs / mode.</span>
        </div>
      </div>
    </div>
  </div> <!-- /#app -->

  <script>
  const { createApp } = Vue;

  const ARABIC_DIACRITICS_RE = /[\u0617-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E8\u06EA-\u06ED]/g;
  const INVISIBLES_RE = /[\ufeff\u200b\u200c\u200d\u2060]/g;
  const stripInvisibles = s => (s || '').replace(INVISIBLES_RE, '');
  const stripDiacritics = s => (s || '').replace(ARABIC_DIACRITICS_RE, '');
  const norm = s => (s || '').normalize('NFC');
  function tokenizeSpace(line, { noDia=false } = {}) {
    line = stripInvisibles(line);
    const raw = line.split(/\s+/).filter(Boolean);
    return raw.map(w => {
      w = norm(stripInvisibles(w.trim()));
      return noDia ? stripDiacritics(w) : w;
    }).filter(w => w.length > 1);
  }

  createApp({
    data() {
      return {
        // UI state
        sidebarOpen: false,

        // tabs
        tab: 'game',

        // tester data
        entries: [],
        map: {},
        index: 0,

        // game
        surah: 1,
        ayahs: [],
        ayahIndex: 0,
        tokens: [],
        guess: [],
        activeSlot: 0,
        options: [],
        revealedCount: 0,

        // feedback
        checked: false,
        perCorrect: [],
        loadingSurah: false,
        checkPulse: '',   // 'success' | 'fail' | ''

        // repetition flow
        repetitionTarget: 3,   // default in settings
        repetitionCount: 0,    // progress within current mode

        // verse range (1-based for UI)
        rangeStart: 1,
        rangeEnd: 1,

        // diacritics mode (DEFAULT: No Diacritics first)
        useNoDiacritics: true,
      }
    },
    computed: {
      activeFilename() {
        return this.useNoDiacritics ? 'similarities_no_diacritics.json' : 'similarities_diacritics.json';
      },
      current() {
        if (!this.entries.length) return null;
        const i = Math.max(0, Math.min(this.index, this.entries.length - 1));
        return this.entries[i];
      },
      isFilled() {
        return this.tokens.length && this.guess.every(Boolean);
      },
      allCorrect() {
        return this.checked && this.perCorrect.length && this.perCorrect.every(Boolean);
      },
      wrongPositions() {
        if (!this.checked) return [];
        const res = [];
        for (let i = 0; i < this.perCorrect.length; i++) {
          if (!this.perCorrect[i]) res.push(i + 1);
        }
        return res;
      }
    },
    methods: {
      // --- Range helpers ---
      normalizeRange(changedStart) {
        const maxAyah = this.ayahs.length || 1;
        // clamp
        this.rangeStart = Math.max(1, Math.min(this.rangeStart || 1, maxAyah));
        this.rangeEnd   = Math.max(1, Math.min(this.rangeEnd   || maxAyah, maxAyah));
        // ensure start <= end
        if (this.rangeStart > this.rangeEnd) {
          if (changedStart) this.rangeEnd = this.rangeStart;
          else this.rangeStart = this.rangeEnd;
        }
        // keep current ayah inside range
        const idx1 = this.ayahIndex + 1;
        if (idx1 < this.rangeStart) {
          this.ayahIndex = this.rangeStart - 1; this.prepareAyah();
        } else if (idx1 > this.rangeEnd) {
          this.ayahIndex = this.rangeEnd - 1; this.prepareAyah();
        }
      },
      goToNextAyahInRange() {
        const nextIndex = this.ayahIndex + 1;
        const endIndex = (this.rangeEnd - 1);
        if (nextIndex <= endIndex) {
          this.ayahIndex = nextIndex;
          // reset to No Diacritics for new ayah and repetitions
          this.useNoDiacritics = true;
          this.repetitionCount = 0;
          this.loadActive();
          this.prepareAyah();
          // subtle hint could be added here if desired
        } else {
          // finished the range
          this.checked = true;
          this.perCorrect = this.tokens.map(() => true);
          this.checkPulse = 'success';
          setTimeout(() => { this.checkPulse = ''; }, 950);
          alert('Completed the selected verse range.');
        }
      },

      // --- Repetition helpers ---
      resetRepetitions() {
        // When user changes the target, reset current progress
        this.repetitionCount = 0;
        if (this.tokens.length) this.restartRound();
      },
      restartRound() {
        // reset the same ayah, same mode, reshuffle bank
        this.guess = Array(this.tokens.length).fill('');
        this.revealedCount = Math.min(1, this.tokens.length);
        this.activeSlot = 0;
        this.checked = false;
        this.perCorrect = [];
        this.checkPulse = '';
        this.buildOptions(); // shuffles options
      },

      // -------- Files (tester similarities) --------
      async loadActive() {
        try {
          const res = await fetch(this.activeFilename, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const obj = await res.json();
          const keys = Object.keys(obj);
          this.entries = keys.map(k => ({ word: k, sims: obj[k] })).filter(e => Array.isArray(e.sims));
          this.map = obj;
          this.index = 0;
          if (this.tokens.length) this.buildOptions();
        } catch (err) {
          this.entries = [];
          this.map = {};
          alert('Could not read ' + this.activeFilename + ': ' + err.message + '\n(Ensure JSONs exist and use a local server)');
        }
      },
      setMode(noDia) {
        if (this.useNoDiacritics === noDia) return;
        this.useNoDiacritics = noDia;
        this.repetitionCount = 0; // new mode -> reset progress
        this.loadActive();
        if (this.ayahs.length) this.prepareAyah();
      },
      clampIndex() {
        if (!this.entries.length) return;
        this.index = Math.max(0, Math.min(this.index, this.entries.length - 1));
      },
      randomIndex() {
        if (!this.entries.length) return;
        this.index = Math.floor(Math.random() * this.entries.length);
      },

      // -------- Surah / Ayah --------
      async loadSurah() {
        try {
          this.loadingSurah = true;
          const url = `https://api.alquran.cloud/v1/surah/${this.surah}/quran-uthmani`;
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const data = await res.json();
          if (data.status !== 'OK') throw new Error(data.message || 'API error');
          this.ayahs = (data.data?.ayahs || []).map(a => a.text || '');
          // Default verse range to first..last
          this.rangeStart = 1;
          this.rangeEnd = this.ayahs.length || 1;
          // reset and go to first in range
          this.ayahIndex = this.rangeStart - 1;
          this.prepareAyah();
        } catch (e) {
          this.ayahs = [];
          this.tokens = [];
          this.guess = [];
          this.activeSlot = 0;
          this.options = [];
          this.checked = false;
          this.perCorrect = [];
          this.revealedCount = 0;
          this.repetitionCount = 0;
          alert('Failed to load surah: ' + e.message);
        } finally {
          this.loadingSurah = false;
        }
      },
      prepareAyah() {
        const noDia = this.useNoDiacritics;
        const line = this.ayahs[this.ayahIndex] || '';
        const tokensRaw = tokenizeSpace(line, { noDia });
        this.tokens = tokensRaw;
        this.guess = Array(tokensRaw.length).fill('');
        this.revealedCount = Math.min(1, tokensRaw.length);
        this.activeSlot = 0;
        this.checked = false;
        this.perCorrect = [];
        this.checkPulse = '';
        this.repetitionCount = 0; // new ayah -> reset progress
        this.buildOptions();
      },
      async randomAyah() {
        this.surah = Math.floor(Math.random() * 114) + 1;
        await this.loadSurah();
        if (this.ayahs.length) {
          // pick random within current range
          const startIdx = this.rangeStart - 1;
          const endIdx = this.rangeEnd - 1;
          this.ayahIndex = Math.floor(Math.random() * (endIdx - startIdx + 1)) + startIdx;
          this.prepareAyah();
        }
      },

      // -------- Word bank for active slot --------
      lookupSimilar(word) {
        if (this.map[word]) return this.map[word];
        const keyNoDia = stripDiacritics(word);
        if (!this.useNoDiacritics && this.map[keyNoDia]) return this.map[keyNoDia];
        return [];
      },
      buildOptions() {
        const target = this.tokens[this.activeSlot] || '';
        const set = new Set();
        if (target) set.add(target);
        const sims = target ? this.lookupSimilar(target) : [];
        for (const [other] of sims) {
          set.add(this.useNoDiacritics ? stripDiacritics(other) : other);
        }
        const arr = Array.from(set).filter(w => w && w.length > 1);
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        this.options = arr;
      },
      reshuffle() { this.buildOptions(); },

      // -------- Slots & choosing --------
      setActive(i) {
        if (i >= 0 && i < this.revealedCount) {
          this.activeSlot = i;
          this.checked = false;
          this.perCorrect = [];
          this.checkPulse = '';
          this.buildOptions();
        }
      },
      choose(opt) {
        this.guess[this.activeSlot] = opt;

        // If all revealed slots are filled and there are more, reveal the next one
        const revealedEmpty = this.guess.slice(0, this.revealedCount).some(g => !g);
        if (!revealedEmpty && this.revealedCount < this.tokens.length) {
          this.revealedCount += 1;
        }

        // Move to next empty within revealed
        const nextEmpty = this.guess.findIndex((g, i) => !g && i < this.revealedCount);
        this.activeSlot = nextEmpty !== -1 ? nextEmpty : Math.min(this.revealedCount - 1, this.tokens.length - 1);

        this.buildOptions();

        // No auto-check; wait for manual Check
        this.checked = false;
        this.perCorrect = [];
        this.checkPulse = '';
      },
      clearAll() {
        this.restartRound();
      },
      checkGuess() {
        if (!this.isFilled) return; // disabled otherwise
        const eq = (a, b) => this.useNoDiacritics ? stripDiacritics(a) === stripDiacritics(b) : a === b;
        this.perCorrect = this.guess.map((g, i) => eq(g, this.tokens[i]));
        this.checked = true;

        // Trigger success/fail pulse on the Check button
        const success = this.perCorrect.every(Boolean);
        this.checkPulse = success ? 'success' : 'fail';
        setTimeout(() => { this.checkPulse = ''; }, 950);

        // Handle repetition/phase progression
        if (success) {
          if (this.repetitionCount + 1 < this.repetitionTarget) {
            // Next repetition in same mode, reshuffle and restart
            this.repetitionCount += 1;
            this.restartRound();
          } else {
            // Completed target reps in current mode
            this.repetitionCount = 0;
            if (this.useNoDiacritics) {
              // switch to diacritics and restart same ayah
              this.useNoDiacritics = false;
              this.loadActive(); // load diacritics file
              this.prepareAyah();
            } else {
              // Completed diacritics cycle too — advance to next ayah in range
              this.goToNextAyahInRange();
            }
          }
        }
      },

      // -------- CSS helpers --------
      slotClass(i) {
        return {
          active: i === this.activeSlot,
          checked: this.checked,
          good: this.checked && this.perCorrect[i],
          bad:  this.checked && !this.perCorrect[i],
        };
      },
      formatScore(s) { return typeof s === 'number' ? s.toFixed(3) : s; }
    },
    async mounted() {
      await this.loadActive();
      await this.loadSurah();  // default surah 1, defaults range to full surah
    }
  }).mount('#app');
  </script>
</body>
</html>
